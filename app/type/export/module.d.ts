// Generated by dts-bundle-generator v9.5.1

declare class ModuleData<Data> {
	constructor(data: Data);
	/**
	 * 触发一个属性的变更事件
	 *
	 * 此方法用于触发特定属性的变更事件它通过获取当前属性的值，并以该值为参数，
	 * 触发该属性的变更事件，以便界面或其他监听此事件的组件能够做出相应的更新
	 *
	 * @param key 要触发变更事件的属性键名，该属性键名是泛型K的一个实例，K是T对象的键的子集
	 */
	touch<K extends keyof Data>(key: K): void;
	/**
	 * 根据给定的键获取默认数据中的值
	 *
	 * 此函数的作用是从默认数据中提取特定的值，通过键来访问
	 * 它确保了类型安全，通过泛型K指定键的类型，保证了只能够访问默认数据中已定义的键
	 *
	 * @param key 要访问的键，必须是默认数据中的一个有效键
	 * @returns 返回对应键的值，类型由默认数据中该键的定义决定
	 */
	get<K extends keyof Data>(key: K): Data[K];
	/**
	 * 设置属性值
	 *
	 * 此方法用于更新对象的属性值，只有当新值与旧值不相同时才会更新
	 * 并且会触发属性变化的事件
	 *
	 * @param key 要设置的属性名称
	 * @param value 要设置的属性值
	 */
	set<K extends keyof Data>(key: K, value: Data[K]): void;
	/**
	 * 为指定的属性添加一个监听器，当属性值发生变化时执行监听器中的处理函数
	 *
	 * @param key 要监听的属性名称
	 * @param handle 当属性值变化时的处理函数，接收新旧值作为参数
	 */
	addListener<K extends keyof Data>(key: K, handle: (value: Data[K], legacy: Data[K]) => void): void;
	/**
	 * 移除指定属性的变更监听器
	 *
	 * 此方法用于从属性监听器列表中移除指定的监听函数当属性发生变更时，系统将不再调用被移除的监听函数
	 *
	 * @param key 要移除监听器的属性名称泛型K用于指定属性的类型，必须是组件默认数据对象中的一个属性键
	 * @param handle 要移除的监听函数，当属性变更时，该函数将被调用
	 *               监听函数接收两个参数：当前值和前一个值
	 */
	removeListener<K extends keyof Data>(key: K, handle: (value: Data[K], legacy: Data[K]) => void): void;
}
export type TMethod = Record<string, (...args: any) => any>;
export type TData = Record<string, any>;
export type TModuleLifeCycleKeys = "register" | "unregister" | "load" | "unload";
export type TModuleStatus = "idle" | "pendding" | "running";
export type TModuleLifeCycle = {
	register?: () => void;
	unregister?: () => void;
	load?: () => void;
	unload?: () => void;
};
export type TModuleExtraData<M, D> = {
	method: M;
	data: D;
};
export type TModule<C extends {} = {}, M = TMethod, D extends () => TData = () => TData> = TModuleLifeCycle & TModuleExtraData<M, D> & ThisType<{
	data: ModuleData<ReturnType<D>>;
} & C>;
/**
 * 模块的容器
 */
export declare class ModuleContainer<C extends {} = {}, M extends TMethod = TMethod, D extends () => TData = () => TData> {
	stash: C;
	status: TModuleStatus;
	constructor(module: TModule<C, M, D>);
	/**
	 * 执行一个生命周期函数
	 * @param name
	 */
	run(name: TModuleLifeCycleKeys): Promise<void>;
	/**
	 * 执行一个 methods 里的函数
	 * @param name
	 */
	execture<K extends keyof M>(name: K, ...args: Parameters<M[K]>): Promise<ReturnType<M[K]>>;
}
/**
 * 创建于一个模块容器
 * @param module
 * @returns
 */
export declare const generateModule: <C extends {} = {}>(module: TModule<C>) => ModuleContainer<C, TMethod, () => TData>;

export {};
